# 视频《玩转算法面试 从真题到思维全面提升算法思维》 学习笔记

## 第二章 面试中的复杂度分析

### 2-1 究竟什么是大O

```
时间复杂度 (什么是大O):	
    对于一个数据规模为n的算法，`O(f(n))` 表示运行算法需要执行的指令数，它和 `f(n)` 成正比.
```

例：

|    算法    |   时间复杂度   |   所需执行指令数   |
|   :---:   |     :---:     |     :---:       |
| 二分查找法  |    O(logn)   |     a * logn     |
| 归并排序算法 |   O(nlogn)  |    b * nlogn    |
| 选择排序法  |    O(nˆ2)    |    c * nˆ2      |

其中, a、b、c 均为常数.

### 2-2 数据规模的概念

对于一个时间复杂度为`O(n)`的算法，`10ˆ8` 个指令数大约需要执行 `0.4s`, 因此, 要在 `1s` 内解决问题：

- O(nˆ2) 的算法可以处理数据量为 10ˆ3 级别的数据
- O(nlogn) 的算法可以处理数据量为 10ˆ6 级别的数据
- O(n) 的算法可以处理数据量为 10ˆ7 级别的数据

保险起见，上述结论是将可以处理的数据规模除以 10 之后得出的。

### 2-4 递归调用算法的时间复杂度分析

#### 一次递归调用

如果递归函数中，只进行一次递归调用，且递归深度为 depth ，在每个递归函数中，时间复杂度为 T，则算法整体的时间复杂度为 O(T * depth)

#### 多次递归调用
结合递归树，具体情况具体分析

```java
int function(int n) {
	assert (n >= 0);
	if(n == 0) {
		return 1;
	}
	return f(n-1) + f(n-1);
}
```

时间复杂度为 O(2ˆn)


### 2-5 均摊时间复杂度

动态数组的扩容算法

### 2-6 避免复杂度的震荡

动态数组的减容算法，在零界点时的处理不当，会导致反复减容之后又扩容

### 其它

- loga(n) = loga(b) * logb(n)

- 2ˆ0 + 2ˆ1 + ...... + 2ˆn = 2ˆn+1 - 1 = O(2ˆn)

## 第三章 数组中的常见问题