# 视频《学习算法思想，修炼编程内功》 学习笔记

## 第一章 课程介绍

## 第二章 排序基础

时间复杂度为O(nˆ2)基础排序算法, 包括:

- 选择排序
- 插入排序


O(nˆ2) 的排序算法优点:

- 在某些情况下更易实现（如在汇编语言中）
- 在特殊情况下更高效
- 简单的排序算法可以衍生出复杂的排序算法（如希尔排序就是对插入排序的优化）
- 作为子过程，改进其它排序算法（如归并和快排经常在最后元素比较少的时候用插入排序）

### 选择排序

- 算法思想  
    
    从待排序数组中选择一个元素,将其插入已排序数组的末端,使已排序数组继续有序,重复上诉过程,直到数组完全有序

- 算法演示动画

	- Gif

		![image](https://github.com/SummerRC/BasicKnowledgeReview/raw/master/算法/gif/选择排序动画.gif)

	- 视频

		<video controls="controls" src="./mov/选择排序动画.mov" width="100%"></video>


- 代码实现

	```java
	@Override
    public void sort(T[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        //外层循环针对[0, n-1]的位置,为其选择合适元素
        for (int i=0; i<array.length; i++) {
            // 寻找[i, length) 区间里的最小值
            int minValuePosition = i;       //待排序数组中最小值的数组下标
            for (int j=i+1; j<array.length; j++) {
                if (array[j].compareTo(array[minValuePosition]) < 0) {
                    minValuePosition = j;
                }
            }
            ArrayUtils.swipe(array, i, minValuePosition);
        }
    }
	```
	
	
### 插入排序

- 算法思想  
    
    将一个元素插入到已排序数组中, 使已排序数组继续有序, 重复上述过程, 直到数组完全有序

- 算法演示动画

	- Gif

		![image](https://github.com/SummerRC/BasicKnowledgeReview/raw/master/算法/gif/插入排序动画.gif)

	- 视频

	<video controls="controls" src="./mov/插入排序动画.mov" width="100%"></video>


- 代码实现

	```java
	@Override
    public void sort(T[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        //外层考虑从[1, length)的无序元素
        for (int i = 1; i < array.length; i++) {
            //寻找array[i]在区间[0, i]合适的插入位置
            for (int j = i; j > 0; j--) {
                if (array[j].compareTo(array[j - 1]) < 0) {
                    ArrayUtils.swipe(array, j, j - 1);
                } else {
                    break;
                }
            }
        }
    }	
    ```
	
- 优化之后的算法演示动画

	- Gif

		![image](https://github.com/SummerRC/BasicKnowledgeReview/raw/master/算法/gif/插入排序优化动画.gif)

	- 视频

		<video controls="controls" src="./mov/插入排序优化动画.mov" width="100%"></video>

- 优化之后的代码实现

	```java
	public void optimizeSort(T[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        //外层考虑从[1, length)的无序元素
        for (int i=1; i<array.length; i++) {
            T e = array[i];     //待插入的元素
            int j;              //元素e应该插入的位置
            //寻找array[i]在区间[0, i]合适的插入位置
            for (j=i; j>0; j--) {
                if (e.compareTo(array[j-1]) < 0) {
                    array[j] = array[j-1];
                } else {
                    break;
                }
            }
            array[j] = e;
        }
    }	
    ```
    
### 其它

- 冒泡排序
- 希尔排序

## 高级排序算法




